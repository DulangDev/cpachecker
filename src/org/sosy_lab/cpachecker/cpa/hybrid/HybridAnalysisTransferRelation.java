/*
 *  CPAchecker is a tool for configurable software verification.
 *  This file is part of CPAchecker.
 *
 *  Copyright (C) 2007-2014  Dirk Beyer
 *  All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *
 *  CPAchecker web page:
 *    http://cpachecker.sosy-lab.org
 */
package org.sosy_lab.cpachecker.cpa.hybrid;

import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Set;

import javax.annotation.Nullable;

import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;

import org.sosy_lab.common.configuration.Option;
import org.sosy_lab.common.configuration.Options;
import org.sosy_lab.common.log.LogManager;
import org.sosy_lab.cpachecker.cfa.CFA;
import org.sosy_lab.cpachecker.cfa.ast.c.CArraySubscriptExpression;
import org.sosy_lab.cpachecker.cfa.ast.c.CBinaryExpression;
import org.sosy_lab.cpachecker.cfa.ast.c.CBinaryExpression.BinaryOperator;
import org.sosy_lab.cpachecker.cfa.ast.c.CDeclaration;
import org.sosy_lab.cpachecker.cfa.ast.c.CExpression;
import org.sosy_lab.cpachecker.cfa.ast.c.CExpressionAssignmentStatement;
import org.sosy_lab.cpachecker.cfa.ast.c.CExpressionStatement;
import org.sosy_lab.cpachecker.cfa.ast.c.CFunctionCallAssignmentStatement;
import org.sosy_lab.cpachecker.cfa.ast.c.CFunctionCallStatement;
import org.sosy_lab.cpachecker.cfa.ast.c.CIdExpression;
import org.sosy_lab.cpachecker.cfa.ast.c.CStatement;
import org.sosy_lab.cpachecker.cfa.model.CFAEdge;
import org.sosy_lab.cpachecker.cfa.model.c.CAssumeEdge;
import org.sosy_lab.cpachecker.cfa.model.c.CDeclarationEdge;
import org.sosy_lab.cpachecker.cfa.model.c.CStatementEdge;
import org.sosy_lab.cpachecker.core.defaults.ForwardingTransferRelation;
import org.sosy_lab.cpachecker.core.defaults.precision.VariableTrackingPrecision;
import org.sosy_lab.cpachecker.core.interfaces.AbstractState;
import org.sosy_lab.cpachecker.core.interfaces.Precision;
import org.sosy_lab.cpachecker.cpa.automaton.CParserUtils;
import org.sosy_lab.cpachecker.cpa.automaton.InvalidAutomatonException;
import org.sosy_lab.cpachecker.cpa.hybrid.abstraction.HybridStrengthenOperator;
import org.sosy_lab.cpachecker.cpa.hybrid.abstraction.HybridValueProvider;
import org.sosy_lab.cpachecker.cpa.hybrid.exception.InvalidAssumptionException;
import org.sosy_lab.cpachecker.cpa.hybrid.util.CollectionUtils;
import org.sosy_lab.cpachecker.cpa.hybrid.util.ExpressionUtils;
import org.sosy_lab.cpachecker.cpa.hybrid.util.StrengthenOperatorFactory;
import org.sosy_lab.cpachecker.cpa.hybrid.visitor.HybridValueDeclarationTransformer;
import org.sosy_lab.cpachecker.cpa.hybrid.visitor.HybridValueIdExpressionTransformer;
import org.sosy_lab.cpachecker.cpa.value.type.Value;
import org.sosy_lab.cpachecker.exceptions.CPATransferException;

@Options(prefix="cpa.hybrid")
public class HybridAnalysisTransferRelation
    extends ForwardingTransferRelation<HybridAnalysisState, HybridAnalysisState, VariableTrackingPrecision> {

  @Option(secure = true, name = "trackAssumptions", description = "Determines whether to track assumptions occurring within the code in the hybrid analysis states.")
  private boolean trackAssumptions = false;

  @Option(secure = true, name = "trackAssignments", description = "Determines whether to track assignments occurring within the code in the hybrid analysis states.")
  private boolean trackAssignments = false;

  private final CFA cfa;
  private final LogManager logger;

  private final AssumptionGenerator assumptionGenerator;


  public HybridAnalysisTransferRelation(
      CFA pCfa,
      LogManager pLogger,
      HybridValueProvider pValueProvider,
      HybridValueDeclarationTransformer pHybridValueDeclarationTransformer,
      HybridValueIdExpressionTransformer pHybridValueIdExpressionTransformer)
  {
    this.cfa = pCfa;
    this.logger = pLogger;
    this.assumptionGenerator = new AssumptionGenerator(
        cfa.getMachineModel(),
        pLogger,
        pValueProvider);
  }

  @Override
  public Collection<? extends AbstractState> strengthen(
      AbstractState pState,
      List<AbstractState> otherStates,
      @Nullable CFAEdge cfaEdge,
      Precision pPrecision)
      throws CPATransferException, InterruptedException {
    // make sure the state to strengthen is of the correct domain
    assert pState instanceof HybridAnalysisState;

    // the correct operator will be generated by the factory
    HybridStrengthenOperator operator;
    HybridAnalysisState stateToStrengthen = (HybridAnalysisState) pState;

    for(AbstractState otherState : otherStates) {
      operator = StrengthenOperatorFactory.provideStrenghtenOperator(otherState);
      stateToStrengthen = operator.strengthen(stateToStrengthen, otherState, cfaEdge);
      super.setInfo(stateToStrengthen, pPrecision, cfaEdge);
    }

    super.resetInfo();
    return Collections.singleton(stateToStrengthen);
  }


  @Override
  protected @Nullable HybridAnalysisState handleAssumption(
      CAssumeEdge cfaEdge, CExpression expression, boolean truthAssumption)
      throws CPATransferException {

    // HybridAnalysis can only handle binary expressions as assumptions
    assert expression instanceof CBinaryExpression;

    // if the edge does not introduce a new assumption or assumptions should not be tracked at all
    if(!trackAssumptions || state.getAssumptions().contains(expression))
    {
      return HybridAnalysisState.copyOf(state);
    }

    Set<CBinaryExpression> assumptions = Sets.newHashSet(state.getExplicitAssumptions());
    CBinaryExpression binaryExpression = (CBinaryExpression) expression;
    CIdExpression variableId = (CIdExpression) binaryExpression.getOperand1();

    // existing variable (within state)
    if(state.tracksVariable(variableId)) {
      // check for existence of the first operand -> assumptionEdge updates the assumption of an already existing variable
      final Collection<CBinaryExpression> matchingAssumptions =
          CollectionUtils.getApplyingElements(assumptions, assumption -> assumption.getOperand1().equals(variableId));

      // at this point exactly one assumption for a variable should existredshift
      if(matchingAssumptions.size() != 1) {
        throw new CPATransferException("Multiple assumptions for the same variable in this state.");
      }

      @Nullable CBinaryExpression existingAssumption = CollectionUtils.first(matchingAssumptions);

      if(existingAssumption != null) {
        // replace the assumption
        assumptions.remove(existingAssumption);
      }
    }

    // possible inversion of logical operation
    assumptions.add(ExpressionUtils.getASTWithTruthAssumption(cfaEdge, binaryExpression));

    return new HybridAnalysisState(ImmutableSet.copyOf(assumptions));
  }

  @Override
  protected HybridAnalysisState handleDeclarationEdge(
      CDeclarationEdge cfaEdge,
      CDeclaration pCDeclaration)
      throws CPATransferException {

    try {

      @Nullable CExpression newAssumption = assumptionGenerator.generateAssumption(pCDeclaration);
      if(newAssumption == null) {
        return HybridAnalysisState.copyOf(state);
      }

      return HybridAnalysisState.copyWithNewAssumptions(state, newAssumption);

    } catch(InvalidAssumptionException iae) {
      throw new CPATransferException(
          "Unable to transform the created value and the given declaration expression into an assumption.",
          iae);
    }
  }

  @Override
  protected HybridAnalysisState handleStatementEdge(
      CStatementEdge pCStatementEdge,
      CStatement pCStatement)
    throws  CPATransferException {

    if(pCStatement instanceof CExpressionStatement || pCStatement instanceof CFunctionCallStatement) {
      return HybridAnalysisState.copyOf(state);
    }

    // simple assignment
    if(pCStatement instanceof CExpressionAssignmentStatement) {

      // we don't want to track assignments
      if(!trackAssignments) {
        return HybridAnalysisState.copyOf(state);
      }

      // handle assignment
      Collection<CStatement> singletonList = Collections.singleton(pCStatement);
      try {
        Collection<CExpression> expressions =
            CollectionUtils.ofType(
                CParserUtils
                    .convertStatementsToAssumptions(singletonList, cfa.getMachineModel(), logger),
                CExpression.class);

        // build new state
        CExpression assignment = CollectionUtils.first(expressions); // first and only

        // save to call with null, because of null check on usage of the edge
        return handleAssumption(null, assignment, true);

      } catch (InvalidAutomatonException e) {
        throw new CPATransferException("Unable to parse CStatement into assumption", e);
      }
    }

    // function call assignment
    if(pCStatement instanceof CFunctionCallAssignmentStatement) {

      CFunctionCallAssignmentStatement statement = (CFunctionCallAssignmentStatement) pCStatement;
      CExpression functionNameExpression = statement.getFunctionCallExpression().getFunctionNameExpression();

      boolean isNondetCall = false;
      if(functionNameExpression instanceof CIdExpression) {

        isNondetCall = isVerifierNondet(((CIdExpression) functionNameExpression).getName());
      } else if(functionNameExpression instanceof CArraySubscriptExpression) {

        CArraySubscriptExpression arraySubscriptExpression = (CArraySubscriptExpression) functionNameExpression;
        CExpression arrayIdentifierExpression = arraySubscriptExpression.getArrayExpression();
        if(arrayIdentifierExpression instanceof CIdExpression) {

          isNondetCall = isVerifierNondet(((CIdExpression) arrayIdentifierExpression).getName());
        }
      }

      if(isNondetCall) {

        // function call is actually nondet
        try {

          @Nullable CExpression newAssumption = assumptionGenerator.generateAssumption(functionNameExpression);
          if(newAssumption == null) {
            return HybridAnalysisState.copyOf(state);
          }

          return HybridAnalysisState.copyWithNewAssumptions(state, newAssumption);
        } catch (InvalidAssumptionException iae) {
          throw new CPATransferException(
              String.format("Unable to generate assumption for function call assignment %s", statement),
              iae);
        }
      }
    }

    return HybridAnalysisState.copyOf(state);
  }

  // to determine whether the identifier name contains nondet-prefix
  private boolean isVerifierNondet(final String pVerifierName) {
    return pVerifierName.startsWith("__VERIFIER_nondet");
  }

}
/*
 *  CPAchecker is a tool for configurable software verification.
 *  This file is part of CPAchecker.
 *
 *  Copyright (C) 2007-2014  Dirk Beyer
 *  All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *
 *  CPAchecker web page:
 *    http://cpachecker.sosy-lab.org
 */
package org.sosy_lab.cpachecker.cpa.hybrid;

import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Set;

import javax.annotation.Nullable;

import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;

import org.sosy_lab.common.log.LogManager;
import org.sosy_lab.cpachecker.cfa.CFA;
import org.sosy_lab.cpachecker.cfa.ast.c.CBinaryExpression;
import org.sosy_lab.cpachecker.cfa.ast.c.CDeclaration;
import org.sosy_lab.cpachecker.cfa.ast.c.CExpression;
import org.sosy_lab.cpachecker.cfa.model.CFAEdge;
import org.sosy_lab.cpachecker.cfa.model.c.CAssumeEdge;
import org.sosy_lab.cpachecker.cfa.model.c.CDeclarationEdge;
import org.sosy_lab.cpachecker.core.defaults.ForwardingTransferRelation;
import org.sosy_lab.cpachecker.core.defaults.precision.VariableTrackingPrecision;
import org.sosy_lab.cpachecker.core.interfaces.AbstractState;
import org.sosy_lab.cpachecker.core.interfaces.Precision;
import org.sosy_lab.cpachecker.cpa.hybrid.abstraction.HybridStrengthenOperator;
import org.sosy_lab.cpachecker.cpa.hybrid.abstraction.HybridValueProvider;
import org.sosy_lab.cpachecker.cpa.hybrid.util.CollectionUtils;
import org.sosy_lab.cpachecker.cpa.hybrid.util.ExpressionUtils;
import org.sosy_lab.cpachecker.cpa.hybrid.util.StrengthenOperatorFactory;
import org.sosy_lab.cpachecker.cpa.hybrid.value.HybridValue;
import org.sosy_lab.cpachecker.cpa.hybrid.visitor.HybridValueTransformer;
import org.sosy_lab.cpachecker.exceptions.CPATransferException;

public class HybridAnalysisTransferRelation
    extends ForwardingTransferRelation<HybridAnalysisState, HybridAnalysisState, VariableTrackingPrecision> {

  private final CFA cfa;
  private final LogManager logger;

  // the value provider is not final, because the strategy might change over time
  private HybridValueProvider valueProvider;
  private final HybridValueTransformer valueTransformer;


  public HybridAnalysisTransferRelation(
      CFA cfa, 
      LogManager logger, 
      HybridValueProvider valueProvider,
      HybridValueTransformer valueTransformer)
  {
    this.cfa = cfa;
    this.logger = logger;
    this.valueProvider = valueProvider;
    this.valueTransformer = valueTransformer;
  }

  @Override
  public Collection<? extends AbstractState> strengthen(
      AbstractState pState,
      List<AbstractState> otherStates,
      @Nullable CFAEdge cfaEdge,
      Precision pPrecision)
      throws CPATransferException, InterruptedException {
    // make sure the state to strengthen is of the correct domain
    assert pState instanceof HybridAnalysisState;

    // the correct operator will be generated by the factory
    HybridStrengthenOperator operator;
    HybridAnalysisState stateToStrengthen = (HybridAnalysisState) pState;

    for(AbstractState otherState : otherStates) {
      operator = StrengthenOperatorFactory.provideStrenghtenOperator(otherState);
      stateToStrengthen = operator.strengthen(stateToStrengthen, otherState, cfaEdge);
      super.setInfo(stateToStrengthen, pPrecision, cfaEdge);
    }


    super.resetInfo();
    return Collections.singleton(stateToStrengthen);
  }

  @Override
  protected @Nullable Collection<HybridAnalysisState> preCheck(HybridAnalysisState pState, VariableTrackingPrecision pPrecision) {

    // TODO: check for states that will definitely not change
    return null;
  }

  @Override
  protected @Nullable HybridAnalysisState handleAssumption(
      CAssumeEdge cfaEdge, CExpression expression, boolean truthAssumption)
      throws CPATransferException {

    // HybridAnalysis can only handle binary Assumptions
    assert expression instanceof CBinaryExpression;

    // if the edge does not introduce a new assumption
    if(state.getAssumptions().contains(expression))
    {
      return HybridAnalysisState.copyOf(state);
    }

    Set<CBinaryExpression> assumptions = Sets.newHashSet(state.getExplicitAssumptions());
    CBinaryExpression binaryExpression = (CBinaryExpression) expression;
    CExpression firstOperand = binaryExpression.getOperand1();

    // check for existance of the first operand -> assumptionEdge updates the assumption of an already exisiting variable
    final Collection<CBinaryExpression> matchingAssumptions = CollectionUtils.getApplyingElements(assumptions, assumption -> assumption.getOperand1().equals(firstOperand));

    // exactly one assumption for a variable should exist at a time, or none at all
    if(matchingAssumptions.size() > 1) {
      throw new CPATransferException("Multiple assumptions for the same variable in this state.");
    }

    @Nullable CBinaryExpression existingAssumption = CollectionUtils.first(matchingAssumptions);

    // there is no assumption for this variable - later on we will use the variable cache of a state to simplify this search
    if(existingAssumption != null) {
      // replace the assumption
      assumptions.remove(existingAssumption);
    } 

    // possible inversion of logical operation
    assumptions.add(ExpressionUtils.getASTWithTruthAssumption(cfaEdge, binaryExpression));

    return new HybridAnalysisState(ImmutableSet.copyOf(assumptions));
  }

  @Override
  protected @Nullable HybridAnalysisState handleDeclarationEdge(CDeclarationEdge cfaEdge, CDeclaration decl)
      throws CPATransferException {
    
    HybridValue value = valueProvider.delegateVisit(decl.getType());
    CExpression newAssumption = valueTransformer.visit(value, decl);

    Set<CExpression> postDeclarationAssumptions = Sets.newHashSet(state.getAssumptions());
    postDeclarationAssumptions.add(newAssumption);

    return new HybridAnalysisState(postDeclarationAssumptions);
  }

}